import { Component, inject, computed, signal } from '@angular/core';
import { GameStateService } from '../../services/game-state.service';
import { ProductionService } from '../../services/production.service';
import { ConstructionService } from '../../services/construction.service';
import { CelestialBody, BODY_TYPE_DEFINITIONS, FEATURE_DEFINITIONS } from '../../models/celestial-body.model';
import { FACILITY_DEFINITIONS, FacilityId } from '../../models/facility.model';
import { RESOURCE_DEFINITIONS, ResourceId } from '../../models/resource.model';

@Component({
  selector: 'app-system-view',
  templateUrl: './system-view.component.html',
  styleUrl: './system-view.component.css'
})
export class SystemViewComponent {
  private gameState = inject(GameStateService);
  private productionService = inject(ProductionService);
  private constructionService = inject(ConstructionService);

  readonly selectedSystem = this.gameState.selectedSystem;
  readonly selectedBody = this.gameState.selectedBody;
  readonly bodies = this.gameState.bodies;
  readonly facilities = this.gameState.facilities;

  selectedFacilityToBuild: FacilityId | null = null;
  showBuildMenu = false;

  // Signal to control whether unavailable facilities are shown
  showUnavailableFacilities = signal<boolean>(true);

  readonly systemBodies = computed(() => {
    const system = this.selectedSystem();
    if (!system) return [];

    const allBodies = system.bodyIds
      .map(id => this.bodies()[id])
      .filter(Boolean);

    // Separate into primary bodies (stars/planets) and moons
    const primaryBodies = allBodies
      .filter(b => !b.parentBodyId)
      .sort((a, b) => {
        // Star first, then sort by name
        if (a.type === 'star') return -1;
        if (b.type === 'star') return 1;
        return a.name.localeCompare(b.name);
      });

    // Build final list with moons placed directly after their parent
    const result: CelestialBody[] = [];
    for (const body of primaryBodies) {
      result.push(body);
      // Find and add moons of this body, sorted by name
      const moons = allBodies
        .filter(b => b.parentBodyId === body.id)
        .sort((a, b) => a.name.localeCompare(b.name));
      result.push(...moons);
    }

    return result;
  });

  readonly systemResources = computed(() => {
    const system = this.selectedSystem();
    if (!system) return [];

    return system.resources
      .filter(r => r.amount > 0)
      .map(r => ({
        ...r,
        name: RESOURCE_DEFINITIONS[r.resourceId]?.name ?? r.resourceId,
        rate: this.productionService.getNetProductionRate(system.id, r.resourceId)
      }))
      .sort((a, b) => (RESOURCE_DEFINITIONS[a.resourceId]?.tier ?? 0) - (RESOURCE_DEFINITIONS[b.resourceId]?.tier ?? 0));
  });

  readonly bodyFacilities = computed(() => {
    const body = this.selectedBody();
    if (!body) return [];

    return body.facilityIds
      .map(id => this.facilities()[id])
      .filter(Boolean)
      .map(f => ({
        ...f,
        definition: FACILITY_DEFINITIONS[f.definitionId]
      }));
  });

  // Available facilities: filter by slot types that actually have open slots, sort by tier then name
  readonly availableFacilities = computed(() => {
    const body = this.selectedBody();
    if (!body) return [];

    const all = this.constructionService.getAvailableFacilities(body.id);

    const surfaceOpen = body.surveyed && body.usedSurfaceSlots < body.surfaceSlots;
    const orbitalOpen = body.surveyed && body.usedOrbitalSlots < body.orbitalSlots;

    const showUnavailable = this.showUnavailableFacilities();

    const state = this.gameState.getState();

    const filtered = all.filter(a => {
      const slotType = a.facility.slotType;
      if (slotType === 'surface' && !surfaceOpen) return false;
      if (slotType === 'orbital' && !orbitalOpen) return false;
      if (!showUnavailable && !a.canBuild) return false;
      return true;
    }).map(a => {
      const cost = this.getCost(a.facility.id as FacilityId);
      // Determine affordability
      const affordable = !!cost && cost.canAfford;

      // Build tooltip
      let tooltip = '';
      if (!a.canBuild) {
        tooltip = a.reason ?? 'Cannot build here';
      } else if (!cost) {
        tooltip = 'Cost unavailable';
      } else {
        const missing: string[] = [];
        if (state.credits < cost.credits) {
          const deficit = cost.credits - state.credits;
          missing.push(`Credits: need ${deficit}`);
        }
        for (const res of cost.resources) {
          if (res.available < res.amount) {
            const d = res.amount - res.available;
            missing.push(`${res.name}: need ${d}`);
          }
        }
        tooltip = missing.length > 0 ? `Missing - ${missing.join(', ')}` : 'Affordable';
      }

      return {
        ...a,
        affordable,
        tooltip
      };
    });

    filtered.sort((a, b) => {
      const tierDiff = a.facility.tier - b.facility.tier;
      if (tierDiff !== 0) return tierDiff;
      return a.facility.name.localeCompare(b.facility.name);
    });

    return filtered;
  });

  // Selected facility cost computed to simplify template expression
  readonly selectedFacilityCost = computed(() => {
    const fid = this.selectedFacilityToBuild;
    if (!fid) return null;
    return this.getCost(fid);
  });

  getBodyTypeName(body: CelestialBody): string {
    return BODY_TYPE_DEFINITIONS[body.type]?.name ?? body.type;
  }

  getFeatureName(feature: string): string {
    return FEATURE_DEFINITIONS[feature as keyof typeof FEATURE_DEFINITIONS]?.name ?? feature;
  }

  selectBody(body: CelestialBody): void {
    this.gameState.selectBody(body.id);
    this.showBuildMenu = false;
  }

  toggleBuildMenu(): void {
    this.showBuildMenu = !this.showBuildMenu;
    this.selectedFacilityToBuild = null;
  }

  toggleShowUnavailableFacilities(): void {
    this.showUnavailableFacilities.update(v => !v);
  }

  selectFacilityToBuild(facilityId: FacilityId): void {
    this.selectedFacilityToBuild = facilityId;
  }

  buildFacility(): void {
    const body = this.selectedBody();
    if (!body || !this.selectedFacilityToBuild) return;

    this.constructionService.buildFacility(this.selectedFacilityToBuild, body.id);
    this.showBuildMenu = false;
    this.selectedFacilityToBuild = null;
  }

  getCost(facilityId: FacilityId): ReturnType<ConstructionService['getConstructionCost']> {
    const body = this.selectedBody();
    if (!body) return null;
    return this.constructionService.getConstructionCost(facilityId, body.id);
  }

  formatNumber(value: number): string {
    if (Math.abs(value) >= 1000000) {
      return (value / 1000000).toFixed(2) + 'M';
    }
    if (Math.abs(value) >= 1000) {
      return (value / 1000).toFixed(1) + 'K';
    }
    if (Math.abs(value) >= 100) {
      return value.toFixed(0);
    }
    return value.toFixed(1);
  }

  formatRate(rate: number): string {
    const formatted = this.formatNumber(rate);
    return rate >= 0 ? `+${formatted}/h` : `${formatted}/h`;
  }
}
